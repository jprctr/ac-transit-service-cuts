{"version":3,"sources":["TransitMap/index.js","App.js","serviceWorker.js","index.js"],"names":["console","log","process","radial","radius","distortion","smoothingRatio","rename","serviceChanges","serviceChangeData","map","change","line","trim","noRouteFeatures","filter","toLowerCase","includes","route","changes","geometry","coordinates","type","unused","acTransitRoutes","feature","RouteBackground","objects","Winter19Routeshape","hexToRgb","hex","result","exec","parseInt","TransitMap","props","changeType","selected","visibleGroups","colorScale","orderScale","setSearchValue","useState","tooltipData","setTooltipData","useDimensions","ref","x","y","width","height","routes","useMemo","sortBy","features","f","scaleKey","color","order","displayRoutes","updateTooltip","datum","fromMap","status","area","group","description","useEffect","find","r","layers","GeoJsonLayer","id","data","stroked","filled","pickable","lineWidthMinPixels","lineWidthMaxPixels","opacity","getLineWidth","getFillColor","getLineColor","onHover","target","object","parameters","depthTest","bounds","geoBounds","defaultViewState","fitBounds","padding","bearing","pitch","className","pickingRadius","initialViewState","controller","getCursor","ContextProvider","MapContext","Provider","mapStyle","mapboxApiAccessToken","preventStyleDiffing","reuseMaps","showCompass","style","borderColor","onClick","properties","PUB_RTE","push","concat","warn","join","typesInOrder","scaleOrdinal","domain","range","isNaN","getSuggestions","value","inputValue","length","getSuggestionValue","suggestion","App","setValue","searchValue","suggestions","setSuggestions","setVisibleGroups","t","reverse","key","groups","nextGroups","slice","background","onMouseMove","e","dataset","alwaysRenderSuggestions","onSuggestionsFetchRequested","onSuggestionsClearRequested","renderSuggestion","isSelected","data-route","shouldRenderSuggestions","inputProps","placeholder","onChange","newValue","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.15e99346.chunk.js","sourcesContent":["import React, { useState, useEffect, useMemo\n  // , useRef \n} from 'react';\nimport { feature } from 'topojson';\nimport sortBy from 'lodash.sortby';\nimport { group } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nimport { geoPath, geoMercator, geoBounds, geoCentroid } from 'd3-geo';\nimport { radial } from 'd3-fisheye';\nimport useDimensions from 'react-use-dimensions';\n// import { MapInteractionCSS } from 'react-map-interaction';\n// import mapboxgl from 'mapbox-gl';\nimport bbox from '@turf/bbox';\nimport { StaticMap, NavigationControl, _MapContext as MapContext, } from 'react-map-gl';\nimport { fitBounds } from 'viewport-mercator-project';\nimport DeckGL from '@deck.gl/react';\nimport { GeoJsonLayer, TextLayer } from '@deck.gl/layers';\n// import {DataFilterExtension} from '@deck.gl/extensions';\n\nimport './styles.css';\n\n// Fall20Routeshape // Missing eliminated routes\n// Summer19Routeshape\nimport Winter19Routeshape from './Winter19Routeshape.geo.json';\n// import Winter19Routeshape from './Winter19Routeshape.json';\nimport RouteBackground from './RouteBackground.json';\nimport serviceChangeData from './ac-transit-service-cuts.json';\n\n//\nconsole.log(process.env.REACT_APP_MAPBOX_TOKEN);\n// let maap;\n// mapboxgl.accessToken = process.env.REACT_APP_MAPBOX_TOKEN;\n\n// const dataFilter = new DataFilterExtension({ filterSize: 1 });\n\nconst ashby = {\n  focus: [-122.269361, 37.854422],\n  distort: radial()\n          .radius(2)\n          .distortion(1.25)\n          .smoothingRatio(0.25),\n};\n\nconst fruitvale = {\n  focus: [-122.224154, 37.774836],\n  distort: radial()\n          .radius(2)\n          .distortion(1.25)\n          .smoothingRatio(0.25),\n};\n\nfunction applyDistortion(coordinate) {\n  return ashby.distort(fruitvale.distort(coordinate));\n}\n\n\n\n// not using for now\nconst offsetGroups = [\n  // {\n  //   name: 'transbay',\n  //   routes: ['800', '707', '706', '703', '702', '701', 'E', 'Z', 'F', 'FS', 'G', 'CB', 'J', 'L', 'LA', 'NL', 'NX', 'NX1', 'NX2', 'NX4', 'P', 'V', 'W', 'B', 'C', 'H', 'NX3', 'NXC', 'O', 'OX', 'S', 'SB'],\n  //   direction: [-2, 4],\n  //   index: 0,\n  //   initIndex: 0,\n  // },\n  // {\n  //   name: 'sanpablo',\n  //   routes: ['72', '72M', '72R', '802'],\n  //   direction: [-4, 0],\n  //   index: 4,\n  //   initIndex: 4,\n  // },\n  // {\n  //   name: '46',\n  //   routes: ['46', '46L'],\n  //   direction: [0, 4],\n  //   index: 0,\n  //   initIndex: 0,\n  // },\n];\n\nconst manualOffsets = {\n  // 'B': { x: -0.25, y: -0.25 },\n  // 'NX1': { x: -0.375, y: 0.125 },\n  // 'NX3': { x: 0.5, y: 0 },\n  // '14': { x: -0.375, y: -0.25 },\n};\n\nexport const rename = {\n  '1': 'BRT/1',\n  // '1': 'BRT (1)',\n};\n\nconst serviceChanges = serviceChangeData.map(change => {\n  change.line = rename[change.line] || change.line;\n  change['change-15'] = change['change-15'].trim() === '' ? 'no change' : change['change-15'];\n  change['change-30'] = change['change-30'].trim() === '' ? 'no change' : change['change-30'];\n  return change;\n});\nconst noRouteFeatures = serviceChanges\n  .filter(change => change.line.toLowerCase().includes('flex'))\n  .map(change => ({\n    route: change.line,\n    changes: change,\n    geometry: {\n      coordinates: [],\n      type: \"MultiLineString\",\n    },\n  }));\n\nconst unused = [];\nconst combinedRoutes = feature(RouteBackground, RouteBackground.objects['1']);\n// const acTransitRoutes = feature(Winter19Routeshape,  Winter19Routeshape.objects.Winter19Routeshape);\nconst acTransitRoutes = Winter19Routeshape;\n// console.log(acTransitRoutes)\nacTransitRoutes.features = acTransitRoutes.features.map(f => {\n  f.route = rename[f.properties.PUB_RTE] || f.properties.PUB_RTE;\n  f.changes = serviceChanges.find(r => r.line === f.route);\n  if (!f.changes) {\n    unused.push(f.route);\n  }\n  return f;\n})\n.filter(f => f.changes); // hiding no info routes for now\nacTransitRoutes.features = acTransitRoutes.features.concat(noRouteFeatures);\n\nconsole.warn(`no information for: ${unused.join(', ')}`);\n\nfunction getCenter(path, geometry) {\n  const [x, y] = path.centroid(geometry);\n  return { x, y };\n};\n\nfunction getBounds(path, geometry) {\n  const bounds = path.bounds(geometry),\n    dx = bounds[1][0] - bounds[0][0],\n    y1 = bounds[0][1],\n    dy = bounds[1][1] - y1,\n    x = (bounds[0][0] + bounds[1][0]) / 2,\n    y = (y1 + bounds[1][1]) / 2;\n  return { dx, dy, x, y };\n};\n\nfunction scaleProjection(geometry, width, height) {\n  const projection = geoMercator().scale(1000).rotate([-11, 0]).translate([width / 2, height / 2]);\n  const path = geoPath().projection(projection);\n  const target = geometry;\n  const { dx, dy, x, y } = getBounds(path, target);\n  const scale = 0.9 / Math.max(dx / width, dy / height) || 1,\n    translate = [width / 2 - scale * x, height / 2 - scale * y];\n  return { projection, path, scale, translate, x, y, dx, dy, };\n};\n\n// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\nfunction flatDeep(arr, d = 1) {\n  return d > 0\n    ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])\n    : arr.slice();\n};\n\nfunction overlapping(box1, box2) {\n  return box1.x2 >= box2.x1 && box1.x1 <= box2.x2 && box1.y1 <= box2.y2 && box1.y2 >= box2.y1;\n}\n\nfunction mapToNest(map) {\n  return Array.from(map, ([key, values]) => ({key, values}));\n}\n\n\nfunction hexToRgb(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? [\n    parseInt(result[1], 16),\n    parseInt(result[2], 16),\n    parseInt(result[3], 16)\n  ] : null;\n}\n\nexport default function TransitMap(props) {\n  const { changeType, selected, visibleGroups, colorScale, orderScale, setSearchValue } = props;\n  // const [mapSettings, setMapSettigns] = useState();\n  // const [routes, setRoutes] = useState();\n  const [viewport, setViewport] = useState();\n  const [tooltipData, setTooltipData] = useState();\n  const [ref, { x, y, width, height }] = useDimensions();\n  // const mapContainer = useRef();\n\n  // console.log(mapContainer);\n  // useEffect(() => {\n  //   if (mapContainer.current) {\n  //     const bounds = geoBounds(acTransitRoutes);\n  //     console.log(bounds);\n  //     const oakland = [-122.271168, 37.804323];\n  //     map = new mapboxgl.Map({\n  //       container: mapContainer.current,\n  //       style: 'mapbox://styles/mapbox/dark-v10',\n  //       center: oakland,\n  //       zoom: 10,\n  //     });\n  //     map.fitBounds(bounds, { padding: 16 });\n\n  //     // const scale = (512) * 0.5 / Math.PI * Math.pow(2, map.getZoom());\n  //     // setMapSettigns({\n  //     //   center: map.getCenter(),\n  //     //   scale,\n  //     // });\n  //   }\n  // }, [mapContainer]);\n  // useEffect(() => {\n  //   acTransitRoutes.features = sortBy(\n  //     sortBy(\n  //       acTransitRoutes.features.map(f => {\n  //         f.scaleKey = f.changes ? f.changes[changeType].trim() : 'other';\n  //         f.color = colorScale(f.scaleKey);\n  //         f.order = orderScale(f.scaleKey);\n  //         // f.path = path(f);\n  //         // f.center = getCenter(path, f);\n  //         return f;\n  //       })\n  //     , f => -f.route)\n  //   , f => f.order);\n  //   setRoutes(acTransitRoutes);\n  // }, []);\n\n\n  const routes = useMemo(() => {\n    // offsetGroups.forEach(g => {\n    //   g.index = g.initIndex;\n    // });\n\n    // if (projection) {\n    //   ashby.distort.focus(projection(ashby.focus));\n    //   fruitvale.distort.focus(projection(fruitvale.focus));\n    // }\n\n    // const labelPositions = [];\n    // return width && path ? (\n    return (\n      sortBy(\n        sortBy(\n          acTransitRoutes.features.map(f => {\n            f.scaleKey = f.changes ? f.changes[changeType].trim() : 'other';\n            f.color = colorScale(f.scaleKey);\n            f.order = orderScale(f.scaleKey);\n            // f.path = path(f);\n            // f.center = getCenter(path, f);\n            return f;\n          })\n        , f => -f.route)\n      , f => f.order)\n    );\n      // .map((f, i) => {\n      //   const offsets = offsetGroups.filter(group => group.routes.includes(f.route));\n      //   if (offsets[0]) {\n      //     const offset = offsets[0];\n      //     f.offsetType = offset.name;\n      //     f.offset = {\n      //       x: offset.direction[0] * offset.index,\n      //       y: offset.direction[1] * offset.index,\n      //     };\n      //     offset.index++;\n      //   } else {\n      //     f.offsetType = 'default';\n      //     f.offset = {\n      //       x: 0,\n      //       y: 0,\n      //     };\n      //   }\n\n      //   if (f.geometry) {\n      //     const size = 0.18; // 0.19; //0.2; // 0.25;\n      //     // const size = 0.2;\n      //     const rectHeight = size / 3 * 4;\n      //     const rectWidth = Math.max(rectHeight, rectHeight / 2 * f.route.length);\n      //     const flatCoordinates = flatDeep(f.geometry.coordinates.slice(), Infinity);\n      //     f.start = applyDistortion(projection(flatCoordinates.slice(0, 2)));\n      //     // f.start = fisheye(projection(flatCoordinates.slice(0, 2)));\n      //     // f.start = projection(flatCoordinates.slice(-2));\n      //     f.start[0] += f.offset.x / scale;\n      //     f.start[1] += f.offset.y / scale;\n      //     let position = f.start;\n      //     let usedPositon = labelPositions.find(lp => overlapping(lp, {\n      //       // x1: position[0] - size,\n      //       // y1: position[1],\n      //       // x2: position[0] + size,\n      //       // y2: position[1] + size,\n      //       x1: position[0] - rectWidth / 2,\n      //       y1: position[1],\n      //       x2: position[0] + rectWidth / 2,\n      //       y2: position[1] + rectHeight,\n      //     }));\n\n      //     if (manualOffsets[f.route]) {\n      //       position[0] += manualOffsets[f.route].x;\n      //       position[1] += manualOffsets[f.route].y;\n      //       // usedPositon = false;\n      //     }\n          \n      //     while (usedPositon) {\n      //       flatCoordinates.splice(0, 2);\n      //       let pos = f.start;\n      //       if (flatCoordinates.length >= 2) {\n      //         pos = applyDistortion(projection(flatCoordinates.slice(0, 2)));\n      //         // pos = fisheye(projection(flatCoordinates.slice(0, 2)));\n      //         pos[0] += f.offset.x / scale;\n      //         pos[1] += f.offset.y / scale;\n      //         usedPositon = labelPositions.find(lp => overlapping(lp, {\n      //           // x1: pos[0] - size,\n      //           // y1: pos[1],\n      //           // x2: pos[0] + size,\n      //           // y2: pos[1] + size,\n      //           x1: pos[0] - rectWidth / 2,\n      //           y1: pos[1],\n      //           x2: pos[0] + rectWidth / 2,\n      //           y2: pos[1] + rectHeight,\n      //         }));\n      //       } else {\n      //         console.log(`default: ${f.route}`);\n      //         usedPositon = false;\n      //       }\n      //       position = pos;\n      //       if (manualOffsets[f.route]) {\n      //         position[0] += manualOffsets[f.route].x / scale;\n      //         position[1] += manualOffsets[f.route].y / scale;\n      //         // usedPositon = false;\n      //       }\n      //     }\n\n      //     labelPositions.push({\n      //       // x1: position[0] - size,\n      //       // y1: position[1],\n      //       // x2: position[0] + size,\n      //       // y2: position[1] + size,\n      //       x1: position[0] - rectWidth / 2,\n      //       y1: position[1],\n      //       x2: position[0] + rectWidth / 2,\n      //       y2: position[1] + rectHeight,\n      //     });\n\n      //     f.labelPos = { x: position[0], y: position[1] };\n      //   }\n\n      //   return f;\n      // })\n    // ) : [];\n  }, [changeType, colorScale, orderScale]);\n\n  const displayRoutes = useMemo(() => (\n    routes.filter(route => visibleGroups.includes(route.scaleKey))\n  ), [routes, visibleGroups]);\n\n  // const highlightRoute = useMemo(() => (selected ? routes.filter(feature => feature.route === selected) : []), [routes]);\n\n  // console.log(routes);\n  // }, [changeType, width, path, colorScale, orderScale, projection, scale]);\n\n\n  // const { projection, path, translate, scale } = useMemo(() => {\n  //     const transform = { translate: [0, 0], scale: 1 };\n  //     if (width && height && mapSettings) {\n  //       console.log(mapSettings);\n  //       const { center, scale } = mapSettings;\n  //       const projection = geoMercator()\n  //         .center([center.lng, center.lat])\n  //         .translate([width / 2, height / 2])\n  //         .scale(scale);\n  //       const path = geoPath().projection(projection);\n  //       return {\n  //         ...transform,\n  //         projection,\n  //         path,\n  //       };\n  //     }\n  //     return transform;\n  // }, [width, height, mapSettings]);\n\n  // const { projection, path, translate, scale } = useMemo(() => (\n  //   width\n  //     ? scaleProjection(acTransitRoutes, width, height)\n  //     : { translate: [0, 0], scale: 0 }\n  // ), [width, height]);\n\n\n  // const routeBackground = useMemo(() => path ? (\n  //   <path\n  //     key='routeBackground'\n  //     id='routeBackground'\n  //     d={path(combinedRoutes)}\n  //     // stroke='#121212'\n  //     stroke='transparent'\n  //     // stroke='#333'\n  //     strokeWidth='1.5'\n  //     fill='none'\n  //   />\n  // ) : null, [path]);\n\n  // const routes = useMemo(() => {\n  //   offsetGroups.forEach(g => {\n  //     g.index = g.initIndex;\n  //   });\n\n  //   if (projection) {\n  //     ashby.distort.focus(projection(ashby.focus));\n  //     fruitvale.distort.focus(projection(fruitvale.focus));\n  //   }\n\n  //   const labelPositions = [];\n  //   return width && path ? (\n  //     sortBy(\n  //       sortBy(\n  //         acTransitRoutes.features.map(f => {\n  //           f.scaleKey = f.changes ? f.changes[changeType].trim() : 'other';\n  //           f.color = colorScale(f.scaleKey);\n  //           f.order = orderScale(f.scaleKey);\n  //           f.path = path(f);\n  //           f.center = getCenter(path, f);\n  //           return f;\n  //         })\n  //       , f => -f.route)\n  //     , f => f.order)\n  //     .map((f, i) => {\n  //       const offsets = offsetGroups.filter(group => group.routes.includes(f.route));\n  //       if (offsets[0]) {\n  //         const offset = offsets[0];\n  //         f.offsetType = offset.name;\n  //         f.offset = {\n  //           x: offset.direction[0] * offset.index,\n  //           y: offset.direction[1] * offset.index,\n  //         };\n  //         offset.index++;\n  //       } else {\n  //         f.offsetType = 'default';\n  //         f.offset = {\n  //           x: 0,\n  //           y: 0,\n  //         };\n  //       }\n\n  //       if (f.geometry) {\n  //         const size = 0.18; // 0.19; //0.2; // 0.25;\n  //         // const size = 0.2;\n  //         const rectHeight = size / 3 * 4;\n  //         const rectWidth = Math.max(rectHeight, rectHeight / 2 * f.route.length);\n  //         const flatCoordinates = flatDeep(f.geometry.coordinates.slice(), Infinity);\n  //         f.start = applyDistortion(projection(flatCoordinates.slice(0, 2)));\n  //         // f.start = fisheye(projection(flatCoordinates.slice(0, 2)));\n  //         // f.start = projection(flatCoordinates.slice(-2));\n  //         f.start[0] += f.offset.x / scale;\n  //         f.start[1] += f.offset.y / scale;\n  //         let position = f.start;\n  //         let usedPositon = labelPositions.find(lp => overlapping(lp, {\n  //           // x1: position[0] - size,\n  //           // y1: position[1],\n  //           // x2: position[0] + size,\n  //           // y2: position[1] + size,\n  //           x1: position[0] - rectWidth / 2,\n  //           y1: position[1],\n  //           x2: position[0] + rectWidth / 2,\n  //           y2: position[1] + rectHeight,\n  //         }));\n\n  //         if (manualOffsets[f.route]) {\n  //           position[0] += manualOffsets[f.route].x;\n  //           position[1] += manualOffsets[f.route].y;\n  //           // usedPositon = false;\n  //         }\n          \n  //         while (usedPositon) {\n  //           flatCoordinates.splice(0, 2);\n  //           let pos = f.start;\n  //           if (flatCoordinates.length >= 2) {\n  //             pos = applyDistortion(projection(flatCoordinates.slice(0, 2)));\n  //             // pos = fisheye(projection(flatCoordinates.slice(0, 2)));\n  //             pos[0] += f.offset.x / scale;\n  //             pos[1] += f.offset.y / scale;\n  //             usedPositon = labelPositions.find(lp => overlapping(lp, {\n  //               // x1: pos[0] - size,\n  //               // y1: pos[1],\n  //               // x2: pos[0] + size,\n  //               // y2: pos[1] + size,\n  //               x1: pos[0] - rectWidth / 2,\n  //               y1: pos[1],\n  //               x2: pos[0] + rectWidth / 2,\n  //               y2: pos[1] + rectHeight,\n  //             }));\n  //           } else {\n  //             console.log(`default: ${f.route}`);\n  //             usedPositon = false;\n  //           }\n  //           position = pos;\n  //           if (manualOffsets[f.route]) {\n  //             position[0] += manualOffsets[f.route].x / scale;\n  //             position[1] += manualOffsets[f.route].y / scale;\n  //             // usedPositon = false;\n  //           }\n  //         }\n\n  //         labelPositions.push({\n  //           // x1: position[0] - size,\n  //           // y1: position[1],\n  //           // x2: position[0] + size,\n  //           // y2: position[1] + size,\n  //           x1: position[0] - rectWidth / 2,\n  //           y1: position[1],\n  //           x2: position[0] + rectWidth / 2,\n  //           y2: position[1] + rectHeight,\n  //         });\n\n  //         f.labelPos = { x: position[0], y: position[1] };\n  //       }\n\n  //       return f;\n  //     })\n  //   ) : [];\n  // }, [changeType, width, path, colorScale, orderScale, projection, scale]);\n\n  // const updateTooltip = useMemo(() => (\n  //   function(datum) {\n  //     const { route, scaleKey, color, path, order, changes } = datum;\n  //     const status = scaleKey;\n  //     const { area, group, description } = changes;\n  //     setSearchValue(route);\n  //     setTooltipData({\n  //       route,\n  //       color,\n  //       path,\n  //       order,\n  //       area,\n  //       group,\n  //       description,\n  //       status,\n  //     });\n  //   }\n  // ), [setSearchValue]);\n\n  const updateTooltip = useMemo(() => (\n    function(datum, fromMap = false) {\n      // const { route, scaleKey, color, path, order, changes } = datum;\n      const { route, scaleKey, color, order, changes } = datum;\n      const status = scaleKey;\n      const { area, group, description } = changes;\n      if (fromMap) {\n        setSearchValue(route);\n      }\n      setTooltipData({\n        route,\n        color,\n        // path,\n        order,\n        area,\n        group,\n        description,\n        status,\n        datum,\n      });\n    }\n  ), [setSearchValue]);\n\n  useEffect(() => {\n    const datum = routes.find(r => r.route === selected);\n    if (datum) {\n      updateTooltip(datum);\n    } else {\n      setTooltipData(null);\n    }\n  }, [updateTooltip, selected, routes, x, y ]);\n\n  // function hoverLine(e) {\n    // const { target } = e;\n    // const { dataset } = target;\n    // const { route } = dataset;\n  // function hoverLine(route) {\n  function hoverLine(target) {\n    // console.log(object);\n    const { object } = target;\n    // let datumToUpdate = false;\n    if (object) {\n      const { route } = object;\n      const datum = routes.filter(r => visibleGroups.includes(r.scaleKey)).find(r => r.route === route);\n      if (datum) {\n        if (!tooltipData || tooltipData.route !== route) {\n          updateTooltip(datum, true);\n          // return true;\n          // datumToUpdate = datum;\n        }\n      }\n    } else {\n      if (selected !== '') {\n        setSearchValue('');\n      }\n      if (tooltipData) {\n        setTooltipData(null);  \n      }\n      \n      \n\n      // console.log(target);\n      // setSeelec(null);\n    }\n    // return false;\n    // if (datumToUpdate) {\n    //   updateTooltip(datumToUpdate);\n    // } else {\n    //   setTooltipData(null);\n    // }\n  }\n\n  // const displayRoutes = useMemo(() => (\n  //   routes.map((r, i) => (\n  //     <g\n  //       key={r.route}\n  //       id={r.route}\n  //       transform={`translate(${r.offset.x / scale}, ${r.offset.y / scale})`}\n  //       className={`route ${r.scaleKey}`}\n  //     >\n  //       <path\n  //         data-route={r.route}\n  //         className='highlight'\n  //         d={r.path}\n  //         stroke={r.color}\n  //         fill='none'\n  //         strokeWidth={1.5 / scale}\n  //         strokeOpacity={0.5}\n  //         pointerEvents='none'\n  //       />\n  //     </g>\n  //   ))\n  // ), [routes, scale]);\n\n  // const displayLabels = useMemo(() => {\n  //   const fontScale = scaleLinear()\n  //   .domain([480, 1440])\n  //   // .domain([480, 960])\n  //   // .range([6, 18])\n  //   // .range([7, 12])\n  //   // .range([7, 14])\n  //   .range([8, 18])\n  //   // .range([9, 18])\n  //   .clamp(true);\n  //   const font = Math.floor(fontScale(Math.min(width, height))) || 9;\n  //   const rectHeight = font / 3 * 4;\n  //   return routes.filter(r => r.labelPos).map((r, i) => {\n  //     const rectWidth = Math.max(rectHeight, rectHeight / 2 * r.route.length);\n  //     return (\n  //       <g\n  //         pointerEvents='none'\n  //         className={`${r.scaleKey}`}\n  //         key={`${r.route}-label`}\n  //       >\n  //         <g transform={`translate(${r.labelPos.x}, ${r.labelPos.y})`}>\n  //           <rect\n  //             data-route={r.route}\n  //             className='target'\n  //             // x={-size / scale}\n  //             // width={size * 2 / scale}\n  //             // x={-size * 0.75 / scale}\n  //             // width={size * 1.5 / scale}\n  //             x={(-rectWidth / 2) / scale}\n  //             width={rectWidth / scale}\n  //             // x={(-size / 2) / scale}\n  //             // width={size / scale}\n  //             height={rectHeight / scale}\n  //             fill='#121212'\n  //             stroke={r.color}\n  //             strokeWidth={1 / scale}\n  //             // fillOpacity={0.75}\n  //             fillOpacity={0.5}\n  //             cursor='pointer'\n  //           />\n  //           <text\n  //             fill='white'\n  //             dy={(font - 0.5) / scale}\n  //             fontSize={font / scale}\n  //             textAnchor='middle'\n  //             pointerEvents='none'\n  //           >\n  //             {r.route}\n  //           </text>\n  //         </g>\n  //       </g>\n  //     )\n  //   })\n  // }, [routes, width, height, scale]);\n  // const groupLayers = useMemo(() => {\n    // const layerMap = mapToNest(group(routes, route => route.scaleKey)).map(group => {   \n\n  // const groupLayers = mapToNest(group(routes, route => route.scaleKey)).map(group => {      \n  //   const color = hexToRgb(colorScale(group.key));\n  //   const categoryVisible = visibleGroups.includes(group.key);\n  //   const opacity = categoryVisible ? 255 : 0;\n  //   const getLineColor = [...color, opacity];\n  //   return new GeoJsonLayer({\n  //     id: `${group.key}-routes`,\n  //     data: group.values,\n  //     stroked: true,\n  //     filled: false,\n  //     pickable: categoryVisible,\n  //     lineWidthMinPixels: 1.5,\n  //     lineWidthMaxPixels: 5,\n  //     opacity: selected ? 0.001 : 1,\n  //     getLineWidth: 10,\n  //     getFillColor: [0, 0, 0, 255],\n  //     getLineColor,\n  //     onHover: hoverLine,\n  //     parameters: {\n  //       depthTest: false,\n  //     },\n  //     updateTriggers: {\n  //       getLineColor: {visibleGroups},\n  //     },\n  //     // transitions: {\n  //     //   getLineColor: 250,\n  //     // },\n  //   });\n  // });\n\n    // console.log(layerMap);\n    // return layerMap;\n    // console.log(Array.from(layerMap));\n\n  // }, [routes]);\n  // console.log(groupLayers);\n  // const highlight\n  //\n\n  const layers = [\n    new GeoJsonLayer({\n      id: 'routes',\n      // data: routes,\n      data: displayRoutes,\n      // data: routes.filter()\n      stroked: true,\n      filled: false,\n      pickable: true,\n      lineWidthMinPixels: 1.5,\n      lineWidthMaxPixels: 5,\n      opacity: selected ? 0.001 : 1,\n      getLineWidth: 10,\n      getFillColor: [0, 0, 0],\n      // getLineColor: route => hexToRgb(colorScale(route.scaleKey)),\n      getLineColor: route => {\n        const color = hexToRgb(colorScale(route.scaleKey))\n        return color;\n        // const noSelectionOrSelected = !selected || route.route === selected;\n        // const categoryVisible = visibleGroups.includes(route.scaleKey);\n        // const opacity = categoryVisible\n        //   // ? noSelectionOrSelected\n        //     ? 255\n        //     // : 10\n        //   : 0;\n        // const opacity = selected === '' ? 255 : 10;\n        // // const opacity = 1;\n        // return [...color, opacity];\n      },\n      onHover: hoverLine,\n      parameters: {\n        depthTest: false,\n      },\n      // updateTriggers: {\n      //   getLineColor: {selected},\n      // //   getFilterValue: {visibleGroups},\n      // },\n      // transitions: {\n      //   getLineColor: 250,\n      // },\n      // filterSize: [0, 2],\n      // getFilterValue: route => {\n      //   // console.log(route.scaleKey);\n      //   // console.log(visibleGroups);\n      //   return visibleGroups.includes(route.scaleKey) ? -1 : 1;\n      // },\n      // extensions: [dataFilter],\n    }),\n    // ...groupLayers,\n    \n    new GeoJsonLayer({\n      id: 'highlightRouteBackground',\n      data: tooltipData ? [tooltipData.datum] : [], // highlightRoute,\n      stroked: true,\n      filled: false,\n      pickable: false,\n      lineWidthMinPixels: 4,\n      lineWidthMaxPixels: 15,\n      // opacity: selected ? 1 : 0,\n      getLineWidth: 10,\n      getFillColor: [0, 0, 0, 255],\n      getLineColor: [255, 255, 255], // route => hexToRgb(colorScale(route.scaleKey)),\n      // onHover: hoverLine,\n      parameters: {\n        depthTest: false,\n      },\n      // transitions: {\n      //   getLineColor: 250,\n      // },\n    }),\n    new GeoJsonLayer({\n      id: 'highlightRoute',\n      data: tooltipData ? [tooltipData.datum] : [], // highlightRoute,\n      stroked: true,\n      filled: false,\n      pickable: false,\n      lineWidthMinPixels: 2,\n      lineWidthMaxPixels: 12,\n      // opacity: selected ? 1 : 0,\n      getLineWidth: 10,\n      getFillColor: [0, 0, 0, 255],\n      getLineColor: route => hexToRgb(colorScale(route.scaleKey)),\n      // onHover: hoverLine,\n      parameters: {\n        depthTest: false,\n      },\n      // updateTriggers: {\n      //   getLineColor: {visibleGroups},\n      // },\n      // transitions: {\n      //   getLineColor: 250,\n      // },\n    }),\n    // new TextLayer({\n    //   id: 'route-labels',\n    //   data: displayRoutes,\n    //   pickable: true,\n    //   onHover: hoverLine,\n    //   getText: route => route.route,\n    //   getPosition: route => geoCentroid(route),\n    //   // getPosition: route => route.geometry.coordinates,\n    //   // getColor: d => DEFAULT_COLOR,\n    //   // getColor: route => hexToRgb(colorScale(route.scaleKey)),\n    //   // getColor: route => !selected || route.route === selected ? [255, 255, 255] : [255, 255, 255, 10],\n    //   opacity: selected ? 0.001 : 1,\n    //   getColor: [255, 255, 255],\n    //   getSize: 16,\n    //   sizeScale: 1,\n    //   // updateTriggers: {\n    //   //   getColor: {selected},\n    //   // },\n    //   // sizeScale: fontSize / 20\n    // }),\n  ];\n\n  const bounds = geoBounds(acTransitRoutes);\n  const defaultViewState = fitBounds({\n    width: width || 100,\n    height: height || 100,\n    padding: 16,\n    bounds,\n  });\n  defaultViewState.bearing = 0;\n  defaultViewState.pitch = 0;\n\n  // console.log('render');s\n\n  return (\n    <div ref={ref} className=\"TransitMap\">\n      <DeckGL\n        layers={layers}\n        pickingRadius={5}\n        initialViewState={defaultViewState}\n        controller={true}\n        getCursor={() => tooltipData ? 'pointer' : 'grab'}\n        ContextProvider={MapContext.Provider}\n      >    \n        <StaticMap\n          mapStyle=\"mapbox://styles/jprctr/ckf7hqkbl2caw19nw1abtzh3c\"\n          mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_TOKEN}\n          preventStyleDiffing={true}\n          reuseMaps\n        />\n        <div className=\"navigationControl\">\n          <NavigationControl showCompass={false} />\n        </div>\n      </DeckGL>\n\n      {\n        // <MapInteractionCSS\n        //   minScale={1}\n        //   maxScale={10}\n        //   showControls={true}\n        //   controlsClass='controls'\n        //   btnClass='control'\n        // >\n        // </MapInteractionCSS>\n        // <div ref={mapContainer} className=\"mapbox\" style={{ width, height }} />\n      }\n      {\n        // <svg className={visibleClassString} width={width} height={height}>\n        //   <rect\n        //     width={width}\n        //     height={height}\n        //     fill='transparent'\n        //     onClick={() => tooltipData ? setTooltipData(null) : {}}\n        //     onTouchStart={() => tooltipData ? setTooltipData(null) : {}}\n        //     onMouseOver={() => tooltipData ? setTooltipData(null) : {}}\n        //   />\n        //   <g transform={`translate(${translate}) scale(${scale})`}>\n        //     <g onMouseMove={hoverLine} onTouchStart={hoverLine}>\n        //       {routeBackground}\n        //       <g className='routes'>\n        //         {displayRoutes}\n        //       </g>\n        //       <g className={`labels ${tooltipData ? 'dim' : ''}`}>\n        //         {displayLabels}\n        //       </g>\n        //     </g>\n        //     {tooltipData ? (\n        //       <g\n        //         key={`${tooltipData.route}-highlight`}\n        //         id={`${tooltipData.route}-highlight`}\n        //         className='spotlight'\n        //         pointerEvents='none'\n        //       >\n        //         <path\n        //           d={tooltipData.path}\n        //           stroke='white'\n        //           fill='none'\n        //           strokeWidth={6 / scale}\n        //           strokeOpacity='1'\n        //         />\n        //         <path\n        //           d={tooltipData.path}\n        //           stroke={tooltipData.color}\n        //           fill='none'\n        //           strokeWidth={3 / scale}\n        //           strokeOpacity='1'\n        //         />\n        //       </g>\n        //     ) : null}\n        //   </g>\n        // </svg>\n      }\n      <div\n        className='tooltip'\n        style={{ borderColor: tooltipData ? tooltipData.color : 'white', opacity: tooltipData ? 1 : 0 }}\n      >\n        <div className='column left'>\n          <div className='row'>\n            <div className='route left'>\n              <span>\n                {tooltipData ? tooltipData.route : ''}\n              </span>\n            </div>\n            <div className='area right'>\n              <span>\n                {tooltipData ? tooltipData.area : ''}\n              </span>\n            </div>\n          </div>\n          <div className='row'>\n            <div className='status left'>\n              <span>\n                {tooltipData ? tooltipData.status : ''}\n              </span>\n            </div>\n            <div className='group right'>\n              <span>\n                {tooltipData ? tooltipData.group : ''}\n              </span>\n            </div>\n          </div>\n        </div>\n        <div className='column right'>\n          <div className='row description'>\n            <div>\n              <span>\n                {tooltipData ? tooltipData.description : ''}\n              </span>\n            </div>\n          </div>\n        </div>\n        <div\n          className='close'\n          style={{ borderColor: tooltipData ? tooltipData.color : 'white' }}\n          onClick={() => setTooltipData(null)}\n        >\n          <div>x</div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React, { useState, useEffect } from 'react';\nimport { scaleOrdinal } from 'd3-scale';\nimport sortBy from 'lodash.sortby';\nimport Autosuggest from 'react-autosuggest';\nimport useDimensions from 'react-use-dimensions';\n\nimport TransitMap, { rename } from './TransitMap'\nimport serviceChanges from './TransitMap/ac-transit-service-cuts.json';\n\nimport './App.css';\n\nconst typesInOrder = ['other', 'increased', 'no change', 'modified', 'reduced', 'eliminated'];\n\nconst colorScale = scaleOrdinal()\n  .domain(typesInOrder)\n  .range(['#a8aaac', '#008e9b', '#10684e', '#ffc75f', '#ff9671', '#CC0000']);\n\nconst orderScale = scaleOrdinal()\n  .domain(typesInOrder)\n  .range([1, 2, 3, 4, 5, 6]);\n\nconst changeType = 'change-30';\nconst routes = sortBy(\n  sortBy(\n    serviceChanges.map(route => {\n      route.route = rename[route.line] || route.line;\n      route.scaleKey = route[changeType].trim();\n      route.scaleKey = route.scaleKey === '' ? 'no change' : route.scaleKey;\n      route.color = colorScale(route.scaleKey);\n      route.order = orderScale(route.scaleKey);\n      return route;\n    }).filter(change => change.line !== '40-duplicate')\n  ,r => isNaN(parseInt(r.route)) ? r.route : parseInt(r.route))\n,r => -r.order);\n\nconst getSuggestions = (value, visibleGroups) => {\n  const inputValue = value.trim().toLowerCase();\n  const inputLength = inputValue.length;\n  return inputLength === 0 ? routes : routes.filter(route => route.route.toLowerCase().includes(inputValue));\n};\n\nconst getSuggestionValue = suggestion => suggestion.route;\n\nfunction App() {\n  const [value, setValue] = useState('');\n  const [searchValue, setSearchValue] = useState('');\n  const [suggestions, setSuggestions] = useState(routes);\n  const [visibleGroups, setVisibleGroups] = useState(typesInOrder);\n  const [ref, { width }] = useDimensions();\n\n  useEffect(() => {\n    setValue(searchValue);\n    setSuggestions(getSuggestions(searchValue, visibleGroups));\n  }, [searchValue, visibleGroups]);\n\n  function updateGroups(id) {\n    setVisibleGroups(groups => {\n      if (groups.includes(id)) {\n        const nextGroups = groups.slice().filter(group => group !== id);\n        return nextGroups.length ? nextGroups : [];\n      } else {\n        return groups.concat([id]);\n      }\n    });\n  }\n\n  const renderSuggestion = (suggestion) => {\n    const isSelected = suggestion.route === value;\n    return (\n      <div\n        className={`suggestion ${isSelected ? 'selected' : ''}`}\n        data-route={suggestion.route}\n        style={{ borderColor: suggestion.color }}\n      >\n        <div className='label'>\n          {suggestion.route}\n        </div>\n        <div className='status'>\n          {suggestion.scaleKey}\n        </div>\n      </div>\n    );\n  };\n\n  // const visibleClassString = visibleGroups.join(' ');\n\n  return (\n    <div ref={ref} className=\"App\">\n      <div className='panel'>\n        <div className='headings'>\n          <div className='title'>\n            Proposed AC Transit Service Cuts \n          </div>\n          <div className='subtitle'>\n            Fall 2020 (30% Scenario)\n          </div>\n        </div>\n        <div className='legend'>\n          {typesInOrder.filter(t => t !== 'other').reverse().map(t => (\n            <div\n              key={t}\n              className='item'\n              onClick={() => updateGroups(t)}\n              style={{ opacity: visibleGroups.includes(t) ? 1 : 0.25 }}\n            >\n              <div className='swatch' style={{ background: colorScale(t) }}/>\n              <div className='label'>\n                {t}\n              </div>\n            </div>\n          ))}\n        </div>\n        <div\n          className='search'\n          onMouseMove={e => {\n            const { target } = e;\n            const { dataset } = target;\n            const { route } = dataset;\n            if (route) {\n              setValue(route);\n            }\n          }}\n        >\n          <Autosuggest\n            alwaysRenderSuggestions={width > 768}\n            suggestions={suggestions.filter(route => visibleGroups.includes(route.scaleKey))}\n            onSuggestionsFetchRequested={({ value }) => setSuggestions(getSuggestions(value, visibleGroups))}\n            onSuggestionsClearRequested={() => {}}\n            getSuggestionValue={getSuggestionValue}\n            renderSuggestion={suggestion => renderSuggestion(suggestion)}\n            shouldRenderSuggestions={() => true}\n            inputProps={{\n              placeholder: 'Search',\n              value,\n              onChange: (e, { newValue }) => setValue(newValue),\n            }}\n          />\n        </div>\n      </div>\n      <TransitMap\n        changeType={changeType}\n        selected={value}\n        // visibleClassString={visibleClassString}\n        visibleGroups={visibleGroups}\n        colorScale={colorScale}\n        orderScale={orderScale}\n        setSearchValue={setSearchValue}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}